---
layout: post
title: "객체지향의 사실과 오해"
date: 2019-11-06 12:37:39 +0900
update: 2019-11-06 12:56:44 +0900
categories: ['object-oriented']
---

* TOC
{:toc}


# 상속

## (p.239) 일반화와 특수화

어떤 타입이 다른 타입보다 일반적이라면 이 타입을 슈퍼타입(supertype)이라고 한다. 어떤 타입이 다른 타입보다 좀 더 특수하다면 이 타입을 서브타입(subtype)이라고 한다. 

* 일반화: 슈퍼타입은 서브타입의 일반화이다.
* 특수화: 서브타입은 슈퍼타입의 특수화다.

## (p.241) 어떤 타입이 다른 타입의 서브타입이 되려면

100% 규칙과 Is-a 규칙을 준수해야 한다.

* 100% 규칙: 슈퍼타입의 정의의 100%가 서브타입에 적용돼야만 한다. 서브타입은 속성과 연관관계 면에서 슈퍼타입과 100% 일치해야 한다.
* Is-a 규칙: 서브타입의 모든 인스턴스는 슈퍼타입 집합에 포함돼야 한다. 이는 대개 영어로 서브타입은 슈퍼타입이다(subtype is a supertype)라는 구문을 만들어서 테스트할 수 있다.

흔히 일반화 관계를 is-a관계라고 한다. "고양이는 육식동물이다". is-a 관계의 본질은 서브타입이 슈퍼타입의 부분집합이라는 것이다.

> 서브타입이 슈퍼타입 정의를 확장하는 경우에는 is-a-kind-of 관계라고 부르기도 한다.

## (p.242) 일반화와 특수화 관계를 구현하는 가장 일반적인 방법은 클래스 간 상속이다. 그러나.

그러나 안타깝게도 모든 상속 관계가 일반화 관계인 것은 아니다. 프로그램 내의 두 클래스 간에 상속 관계가 존재할 때 이 관계를 반드시 일반화 관계라고 할 수는 없다.

왜 그럴까?

읽는 중...

## (p.243) 상속은 서브타이핑과 서브클래스의 두 가지 용도로 사용된다

* 서브타이핑
    * 서브클래스가 슈퍼클래스를 대체할 수 있는 경우 이를 서브타이핑이라고 한다.
    * 설계의 유연성이 목표이다.
* 서브클래싱
    * 서브클래스가 슈퍼클래스를 대체할 수 없는 경우에는 서브클래싱이라고 한다.
    * 코드의 중복 제거와 재사용이 목적이다.

흔히 서브타이핑을 인터페이스 상속(interface inheritance)이라고 하고, 서브클래싱을 구현 상속(implementation inheritance)이라고 한다.

안타깝게도 클래스가 다른 클래스를 상속받았다는 사실만으로 두 클래스 간의 관계가 서브타이핑인지, 서브클래싱인지 여부를 결정할 수는 없다. 서브타이핑의 전제 조건은 대체 가능성이기 때문에 서브타이핑인지 여부를 확인하려면 클라이언트 관점에서 실제로 어떻게 사용되고 있는지를 확인해야 한다.

요약하면:

* 일반화를 위한 서브타이핑은 특정 기대 집합에 대한 서브타입과 슈퍼타입 간의 구조적 또는 행위적 순응 관계를 의미하며 대체 가능성을 내포한다.
* 상속은 서브타이핑을 프로그래밍 언어적으로 구현하는 데 사용될 수 있지만 모든 상속이 서브타이핑인 것은 아니다.
* 서브클래스가 슈퍼클래스를 대체할 수 없고 단지 코드만 공유하고 있다면 서브타이핑이 아니라 서브클래싱이라고 한다.
* 가능한 모든 상속 관계가 서브타이핑의 대체 가능성을 준수하도록 주의 깊게 사용하는 것은 코드를 유연하게 만들고 재사용성을 높이는 한 가지 방법이다.

## (p.243) 클래스 간의 위임

여러 클래스로 구성된 상속 계층에서 수신된 메시지를 이해하는 기본적인 방법은 클래스 간의 위임(delegation)을 사용하는 것이다. 어떤 객체의 클래스가 수신된 메시지를 이해할 수 없다면 메시지를 클래스의 부모 클래스로 위임한다. 만약 부모 클래스에서도 메시지를 이해할 수 없다면 자신의 부모 클래스로 다시 메시지를 위임한다. 클래스 간의 위임 사슬은 계층 내의 어떤 클래스가 메시지를 처리하거나 가장 최상위 부모 클래스에 위임될 때까지 계속된다.



